"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatePOST = exports.validateGET = exports.checkKey = exports.ValidationError = void 0;
const type_is_1 = __importDefault(require("type-is"));
class ValidationError extends Error {
    constructor(status, code, key, message) {
        super(message);
        this.status = status;
        this.code = code;
        this.key = key;
    }
}
exports.ValidationError = ValidationError;
function checkKey(value, type) {
    if (Array.isArray(type)) {
        for (const option of type) {
            if (checkKey(value, option))
                return true;
        }
        return false;
    }
    if (type instanceof RegExp) {
        if (value === undefined)
            value = '';
        if (typeof value !== 'string')
            return false;
        return type.test(value);
    }
    if (type.startsWith('?')) {
        if (value === undefined || value === '' || value === null)
            return true;
        type = type.substring(1);
    }
    switch (type) {
        case 'null':
            return value === null;
        case 'array':
            return Array.isArray(value);
        case 'string':
            // NOTE: the character ranges U+0000-U+001F and U+007F-U+009F are control
            // characters (NUL, BACKSPACE, DEL, etc.) that have special meaning in many
            // contexts
            // there is no reason to allow them, anywhere
            /* eslint no-control-regex: "off" */
            return typeof value === 'string' && !!value && !/[\x00-\x08\x0e-\x1f\x7f-\x9f]/.test(value);
        case 'boolean':
            // a checkbox is either present (== 1) or absent (== undefined)
            // for api compatibility, also allow true/false
            return value === undefined || value === '1' || value === '' || value === true || value === false;
        // NOTE: parseInt/parseFloat have weird behavior with trailing garbage
        // we don't want to accept that, so we use the unary "+" operator to
        // convert to a number instead
        case 'number':
            return typeof value === 'string' && value !== '' && Number.isFinite(+value);
        case 'integer':
            return typeof value === 'string' && value !== '' && Number.isInteger(+value);
        case 'object':
            return typeof value === 'object' && !Array.isArray(value);
        default:
            // should never be reached
            return false;
    }
}
exports.checkKey = checkKey;
function failKey(key) {
    return new ValidationError(400 /* Bad Request */, 'E_BAD_PARAM', key, `missing or invalid parameter ${key}`);
}
function failContentType() {
    return new ValidationError(415 /* Not Acceptable */, 'E_BAD_CONTENT_TYPE', null, `invalid content-type`);
}
function _validate(req, res, next, body, keys) {
    for (const key in keys) {
        if (!checkKey(body[key], keys[key])) {
            next(failKey(key));
            return;
        }
    }
    next();
}
function validateGET(keys, options = {}) {
    return function (req, res, next) {
        _validate(req, res, next, req.query, keys);
    };
}
exports.validateGET = validateGET;
function validatePOST(keys, options = {}) {
    return function (req, res, next) {
        if (options.accept && !(0, type_is_1.default)(req, options.accept)) {
            next(failContentType());
            return;
        }
        _validate(req, res, next, req.body, keys);
    };
}
exports.validatePOST = validatePOST;
//# sourceMappingURL=index.js.map